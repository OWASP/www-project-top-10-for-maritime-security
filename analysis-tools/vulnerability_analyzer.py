#!/usr/bin/env python3
"""
OWASP Maritime Security - Vulnerability Analyzer
Version: 1.0

This tool analyzes the maritime vulnerability database and generates
risk scores, reports, and visualizations to support the development
of the OWASP Top 10 for Maritime Security.

Usage:
    python vulnerability_analyzer.py --analyze
    python vulnerability_analyzer.py --report
    python vulnerability_analyzer.py --export-csv output.csv
"""

import yaml
import json
import argparse
from pathlib import Path
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime


@dataclass
class VulnerabilityMetrics:
    """Metrics for vulnerability risk assessment"""
    frequency: float = 0.0
    impact: float = 0.0
    exploitability: float = 0.0
    prevalence: float = 0.0
    detection_difficulty: float = 0.0
    risk_score: float = 0.0


class MaritimeVulnerabilityAnalyzer:
    """Analyzes maritime cybersecurity vulnerabilities"""
    
    # Risk score weights based on methodology
    WEIGHTS = {
        'frequency': 0.25,
        'impact': 0.35,
        'exploitability': 0.20,
        'prevalence': 0.15,
        'detection_difficulty': 0.05
    }
    
    def __init__(self, data_path: str = '../vulnerabilities'):
        """Initialize analyzer with path to vulnerability data"""
        self.data_path = Path(data_path)
        self.vulnerabilities = []
        self.threat_actors = []
        self.incidents = []
        
    def load_data(self):
        """Load vulnerability, threat actor, and incident data"""
        # Load vulnerabilities
        vuln_file = self.data_path / 'maritime_vulnerabilities.yaml'
        if vuln_file.exists():
            with open(vuln_file, 'r') as f:
                vuln_data = yaml.safe_load(f)
                self.vulnerabilities = vuln_data.get('vulnerabilities', [])
        
        # Load threat actors
        ta_file = self.data_path / 'threat_actors.yaml'
        if ta_file.exists():
            with open(ta_file, 'r') as f:
                ta_data = yaml.safe_load(f)
                self.threat_actors = ta_data.get('threat_actors', [])
        
        # Load incidents
        inc_file = self.data_path / 'incidents.yaml'
        if inc_file.exists():
            with open(inc_file, 'r') as f:
                inc_data = yaml.safe_load(f)
                self.incidents = inc_data.get('incidents', [])
        
        print(f"Loaded {len(self.vulnerabilities)} vulnerabilities, "
              f"{len(self.threat_actors)} threat actors, "
              f"{len(self.incidents)} incidents")
    
    def calculate_risk_score(self, vuln: Dict[str, Any]) -> float:
        """
        Calculate risk score for a vulnerability based on methodology
        
        Risk_Score = (Frequency × 0.25) + (Impact × 0.35) + (Exploitability × 0.20) +
                     (Prevalence × 0.15) + (Detection_Difficulty × 0.05)
        """
        # Extract CVSS score as base for metrics
        cvss = vuln.get('cvss_score', 5.0)
        
        # Map severity to numeric values
        severity_map = {
            'Critical': 10,
            'High': 8,
            'Medium': 5,
            'Low': 3
        }
        
        severity_score = severity_map.get(vuln.get('severity', 'Medium'), 5)
        
        # Estimate metrics from available data
        # In production, these would come from detailed analysis
        metrics = VulnerabilityMetrics()
        
        # Frequency: based on incidents and prevalence description
        prevalence_text = vuln.get('prevalence', '').lower()
        if 'critical' in prevalence_text or 'very high' in prevalence_text:
            metrics.frequency = 9.0
        elif 'high' in prevalence_text:
            metrics.frequency = 7.0
        elif 'medium' in prevalence_text:
            metrics.frequency = 5.0
        else:
            metrics.frequency = 3.0
        
        # Impact: use CVSS and severity
        metrics.impact = cvss
        
        # Exploitability
        exploit_text = vuln.get('exploitability', '').lower()
        if 'very high' in exploit_text or 'high' in exploit_text:
            metrics.exploitability = 8.0
        elif 'medium' in exploit_text:
            metrics.exploitability = 5.0
        else:
            metrics.exploitability = 3.0
        
        # Prevalence
        metrics.prevalence = severity_score
        
        # Detection difficulty
        detection_text = vuln.get('detection_difficulty', '').lower()
        if 'very high' in detection_text or 'high' in detection_text:
            metrics.detection_difficulty = 8.0
        elif 'medium' in detection_text:
            metrics.detection_difficulty = 5.0
        else:
            metrics.detection_difficulty = 3.0
        
        # Calculate weighted risk score
        risk_score = (
            metrics.frequency * self.WEIGHTS['frequency'] +
            metrics.impact * self.WEIGHTS['impact'] +
            metrics.exploitability * self.WEIGHTS['exploitability'] +
            metrics.prevalence * self.WEIGHTS['prevalence'] +
            metrics.detection_difficulty * self.WEIGHTS['detection_difficulty']
        )
        
        return round(risk_score, 2)
    
    def analyze_vulnerabilities(self) -> List[Dict[str, Any]]:
        """Analyze all vulnerabilities and calculate risk scores"""
        results = []
        
        for vuln in self.vulnerabilities:
            risk_score = self.calculate_risk_score(vuln)
            
            result = {
                'id': vuln.get('id'),
                'name': vuln.get('name'),
                'category': vuln.get('category'),
                'severity': vuln.get('severity'),
                'cvss_score': vuln.get('cvss_score'),
                'calculated_risk_score': risk_score,
                'affected_systems_count': len(vuln.get('affected_systems', [])),
                'mitigation_count': len(vuln.get('mitigation', [])),
                'incident_count': len(vuln.get('related_incidents', []))
            }
            results.append(result)
        
        # Sort by risk score descending
        results.sort(key=lambda x: x['calculated_risk_score'], reverse=True)
        
        return results
    
    def generate_report(self) -> str:
        """Generate comprehensive analysis report"""
        analysis_results = self.analyze_vulnerabilities()
        
        report = []
        report.append("=" * 80)
        report.append("OWASP MARITIME CYBERSECURITY VULNERABILITY ANALYSIS REPORT")
        report.append("=" * 80)
        report.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"Total Vulnerabilities Analyzed: {len(self.vulnerabilities)}")
        report.append(f"Total Threat Actors: {len(self.threat_actors)}")
        report.append(f"Total Incidents: {len(self.incidents)}")
        report.append("")
        
        # Top 10 by risk score
        report.append("TOP 10 VULNERABILITIES BY RISK SCORE")
        report.append("-" * 80)
        report.append(f"{'Rank':<6} {'ID':<10} {'Risk':<6} {'CVSS':<6} {'Name':<50}")
        report.append("-" * 80)
        
        for idx, vuln in enumerate(analysis_results[:10], 1):
            report.append(
                f"{idx:<6} {vuln['id']:<10} {vuln['calculated_risk_score']:<6.2f} "
                f"{vuln['cvss_score']:<6.1f} {vuln['name'][:48]:<50}"
            )
        
        report.append("")
        
        # Category breakdown
        report.append("VULNERABILITY BREAKDOWN BY CATEGORY")
        report.append("-" * 80)
        
        categories = {}
        for vuln in self.vulnerabilities:
            cat = vuln.get('category', 'Unknown')
            categories[cat] = categories.get(cat, 0) + 1
        
        for cat, count in sorted(categories.items(), key=lambda x: x[1], reverse=True):
            report.append(f"  {cat:<40} {count:>3} vulnerabilities")
        
        report.append("")
        
        # Severity distribution
        report.append("SEVERITY DISTRIBUTION")
        report.append("-" * 80)
        
        severities = {}
        for vuln in self.vulnerabilities:
            sev = vuln.get('severity', 'Unknown')
            severities[sev] = severities.get(sev, 0) + 1
        
        for sev in ['Critical', 'High', 'Medium', 'Low']:
            count = severities.get(sev, 0)
            pct = (count / len(self.vulnerabilities) * 100) if self.vulnerabilities else 0
            bar = '█' * int(pct / 5)
            report.append(f"  {sev:<12} {count:>3} ({pct:>5.1f}%) {bar}")
        
        report.append("")
        
        # Threat actor summary
        if self.threat_actors:
            report.append("THREAT ACTOR SUMMARY")
            report.append("-" * 80)
            
            active_actors = [ta for ta in self.threat_actors if ta.get('active', False)]
            report.append(f"  Total Threat Actors: {len(self.threat_actors)}")
            report.append(f"  Currently Active: {len(active_actors)}")
            report.append("")
            
            report.append("  Top Threats:")
            for ta in self.threat_actors[:5]:
                name = ta.get('name', 'Unknown')
                attribution = ta.get('attribution', 'Unknown')
                sophistication = ta.get('sophistication', 'Unknown')
                report.append(f"    • {name} - {attribution} ({sophistication})")
        
        report.append("")
        
        # Recent incidents
        if self.incidents:
            report.append("RECENT MARITIME CYBER INCIDENTS")
            report.append("-" * 80)
            
            sorted_incidents = sorted(
                self.incidents,
                key=lambda x: x.get('date', '2000-01-01'),
                reverse=True
            )
            
            for inc in sorted_incidents[:5]:
                name = inc.get('name', 'Unknown')
                date = inc.get('date', 'Unknown')
                org = inc.get('organization', 'Unknown')
                severity = inc.get('severity', 'Unknown')
                report.append(f"  [{date}] {name}")
                report.append(f"    Organization: {org} | Severity: {severity}")
                report.append("")
        
        report.append("=" * 80)
        report.append("For detailed methodology, see methodology/METHODOLOGY.md")
        report.append("=" * 80)
        
        return "\n".join(report)
    
    def export_csv(self, output_file: str):
        """Export analysis results to CSV"""
        import csv
        
        analysis_results = self.analyze_vulnerabilities()
        
        with open(output_file, 'w', newline='') as f:
            fieldnames = [
                'Rank', 'ID', 'Name', 'Category', 'Severity', 
                'CVSS_Score', 'Risk_Score', 'Affected_Systems', 
                'Mitigation_Controls', 'Related_Incidents'
            ]
            
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            
            for idx, vuln in enumerate(analysis_results, 1):
                writer.writerow({
                    'Rank': idx,
                    'ID': vuln['id'],
                    'Name': vuln['name'],
                    'Category': vuln['category'],
                    'Severity': vuln['severity'],
                    'CVSS_Score': vuln['cvss_score'],
                    'Risk_Score': vuln['calculated_risk_score'],
                    'Affected_Systems': vuln['affected_systems_count'],
                    'Mitigation_Controls': vuln['mitigation_count'],
                    'Related_Incidents': vuln['incident_count']
                })
        
        print(f"Analysis results exported to {output_file}")
    
    def export_json(self, output_file: str):
        """Export analysis results to JSON"""
        analysis_results = self.analyze_vulnerabilities()
        
        export_data = {
            'metadata': {
                'generated': datetime.now().isoformat(),
                'total_vulnerabilities': len(self.vulnerabilities),
                'total_threat_actors': len(self.threat_actors),
                'total_incidents': len(self.incidents),
                'methodology_version': '1.0'
            },
            'top_10': analysis_results[:10],
            'all_vulnerabilities': analysis_results
        }
        
        with open(output_file, 'w') as f:
            json.dump(export_data, f, indent=2)
        
        print(f"Analysis results exported to {output_file}")


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='OWASP Maritime Security Vulnerability Analyzer'
    )
    parser.add_argument(
        '--analyze',
        action='store_true',
        help='Analyze vulnerabilities and display report'
    )
    parser.add_argument(
        '--report',
        action='store_true',
        help='Generate detailed report'
    )
    parser.add_argument(
        '--export-csv',
        metavar='FILE',
        help='Export results to CSV file'
    )
    parser.add_argument(
        '--export-json',
        metavar='FILE',
        help='Export results to JSON file'
    )
    parser.add_argument(
        '--data-path',
        default='../vulnerabilities',
        help='Path to vulnerability data directory'
    )
    
    args = parser.parse_args()
    
    # Initialize analyzer
    analyzer = MaritimeVulnerabilityAnalyzer(args.data_path)
    
    print("Loading maritime vulnerability data...")
    analyzer.load_data()
    print()
    
    if args.analyze or args.report:
        report = analyzer.generate_report()
        print(report)
    
    if args.export_csv:
        analyzer.export_csv(args.export_csv)
    
    if args.export_json:
        analyzer.export_json(args.export_json)
    
    if not any([args.analyze, args.report, args.export_csv, args.export_json]):
        parser.print_help()


if __name__ == '__main__':
    main()
